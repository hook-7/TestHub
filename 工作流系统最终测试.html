<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>å·¥ä½œæµè‡ªåŠ¨åŒ–ç³»ç»Ÿæµ‹è¯•</title>
    <style>
        body {
            font-family: 'Microsoft YaHei', Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            padding: 30px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        .header {
            text-align: center;
            color: #333;
            margin-bottom: 30px;
        }
        .section {
            margin: 30px 0;
            padding: 20px;
            border: 1px solid #ddd;
            border-radius: 8px;
            background: #fafafa;
        }
        .button {
            background: #409EFF;
            color: white;
            border: none;
            padding: 12px 24px;
            border-radius: 6px;
            cursor: pointer;
            margin: 8px;
            font-size: 14px;
        }
        .button:hover {
            background: #66b1ff;
        }
        .button:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        .button.success {
            background: #67c23a;
        }
        .button.warning {
            background: #e6a23c;
        }
        .button.danger {
            background: #f56c6c;
        }
        .result {
            margin-top: 15px;
            padding: 15px;
            border-radius: 5px;
            font-family: monospace;
            white-space: pre-wrap;
            max-height: 300px;
            overflow-y: auto;
        }
        .success {
            background: #f0f9ff;
            border: 1px solid #67c23a;
            color: #67c23a;
        }
        .error {
            background: #fef0f0;
            border: 1px solid #f56c6c;
            color: #f56c6c;
        }
        .info {
            background: #f4f4f5;
            border: 1px solid #909399;
            color: #909399;
        }
        .workflow-card {
            border: 1px solid #e4e7ed;
            border-radius: 8px;
            padding: 16px;
            margin: 12px 0;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
        }
        .workflow-card:hover {
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            transform: translateY(-2px);
        }
        .workflow-title {
            font-size: 16px;
            font-weight: 600;
            color: #303133;
            margin-bottom: 8px;
        }
        .workflow-desc {
            color: #606266;
            margin-bottom: 12px;
        }
        .step-list {
            font-size: 13px;
            color: #909399;
        }
        .ws-status {
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 12px;
            margin: 8px 0;
        }
        .ws-connected {
            background: #f0f9ff;
            border: 1px solid #67c23a;
            color: #67c23a;
        }
        .ws-disconnected {
            background: #fef0f0;
            border: 1px solid #f56c6c;
            color: #f56c6c;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ”„ å·¥ä½œæµè‡ªåŠ¨åŒ–ç³»ç»Ÿæµ‹è¯•</h1>
            <p>æµ‹è¯•æ­¥éª¤åŒ–æµç¨‹ã€å˜é‡å¼•ç”¨å’ŒWebSocketç¡®è®¤åŠŸèƒ½</p>
        </div>

        <!-- WebSocketè¿æ¥çŠ¶æ€ -->
        <div class="section">
            <h3>ğŸŒ WebSocketè¿æ¥</h3>
            <div id="ws-status" class="ws-status ws-disconnected">âŒ WebSocketæœªè¿æ¥</div>
            <button class="button" onclick="connectWebSocket()">è¿æ¥WebSocket</button>
            <button class="button" onclick="disconnectWebSocket()">æ–­å¼€è¿æ¥</button>
            <div id="ws-result" class="result info">ç­‰å¾…è¿æ¥...</div>
        </div>

        <!-- å·¥ä½œæµåˆ—è¡¨ -->
        <div class="section">
            <h3>ğŸ“‹ å¯ç”¨å·¥ä½œæµ</h3>
            <button class="button" onclick="loadWorkflows()">åŠ è½½å·¥ä½œæµåˆ—è¡¨</button>
            <div id="workflows-container"></div>
            <div id="workflows-result" class="result"></div>
        </div>

        <!-- å·¥ä½œæµæ‰§è¡Œ -->
        <div class="section">
            <h3>ğŸš€ æ‰§è¡Œå·¥ä½œæµ</h3>
            <button class="button success" onclick="executeATTest()">æ‰§è¡ŒATæµ‹è¯•æµç¨‹</button>
            <button class="button warning" onclick="executeDeviceRestart()">æ‰§è¡Œè®¾å¤‡é‡å¯æµç¨‹</button>
            <div id="execution-result" class="result"></div>
        </div>

        <!-- æ‰§è¡Œç›‘æ§ -->
        <div class="section">
            <h3>ğŸ“Š æ‰§è¡Œç›‘æ§</h3>
            <button class="button" onclick="getExecutions()">è·å–æ‰§è¡Œåˆ—è¡¨</button>
            <div id="monitoring-result" class="result"></div>
        </div>

        <!-- å˜é‡æµ‹è¯• -->
        <div class="section">
            <h3>ğŸ”§ å˜é‡ç³»ç»Ÿæµ‹è¯•</h3>
            <p>æµ‹è¯•å˜é‡è§£æåŠŸèƒ½ï¼š</p>
            <input type="text" id="variable-test" placeholder="è¾“å…¥åŒ…å«å˜é‡çš„æ–‡æœ¬ï¼Œå¦‚: è®¾å¤‡ ${device_id} çŠ¶æ€" style="width: 300px; padding: 8px;">
            <button class="button" onclick="testVariableResolve()">æµ‹è¯•è§£æ</button>
            <div id="variable-result" class="result"></div>
        </div>
    </div>

    <script>
        const BASE_URL = 'http://localhost:8000/api/v1/workflow';
        let websocket = null;
        let currentExecutions = [];

        // WebSocketè¿æ¥
        function connectWebSocket() {
            try {
                const wsUrl = `ws://localhost:8000/api/v1/workflow/ws/WS_TEST`;
                websocket = new WebSocket(wsUrl);
                
                websocket.onopen = function() {
                    updateWSStatus(true);
                    showResult('ws-result', 'WebSocketè¿æ¥æˆåŠŸï¼', 'success');
                    
                    // å‘é€å¿ƒè·³
                    setInterval(() => {
                        if (websocket && websocket.readyState === WebSocket.OPEN) {
                            websocket.send(JSON.stringify({ type: 'heartbeat' }));
                        }
                    }, 30000);
                };
                
                websocket.onmessage = function(event) {
                    const message = JSON.parse(event.data);
                    handleWebSocketMessage(message);
                };
                
                websocket.onclose = function() {
                    updateWSStatus(false);
                    showResult('ws-result', 'WebSocketè¿æ¥æ–­å¼€', 'error');
                };
                
                websocket.onerror = function(error) {
                    updateWSStatus(false);
                    showResult('ws-result', `WebSocketé”™è¯¯: ${error}`, 'error');
                };
                
            } catch (error) {
                showResult('ws-result', `è¿æ¥å¤±è´¥: ${error.message}`, 'error');
            }
        }

        function disconnectWebSocket() {
            if (websocket) {
                websocket.close();
                websocket = null;
                updateWSStatus(false);
                showResult('ws-result', 'WebSocketå·²æ–­å¼€', 'info');
            }
        }

        function updateWSStatus(connected) {
            const statusEl = document.getElementById('ws-status');
            if (connected) {
                statusEl.className = 'ws-status ws-connected';
                statusEl.textContent = 'âœ… WebSocketå·²è¿æ¥';
            } else {
                statusEl.className = 'ws-status ws-disconnected';
                statusEl.textContent = 'âŒ WebSocketæœªè¿æ¥';
            }
        }

        // å¤„ç†WebSocketæ¶ˆæ¯
        function handleWebSocketMessage(message) {
            console.log('æ”¶åˆ°WebSocketæ¶ˆæ¯:', message);
            
            if (message.message_type === 'user_confirmation_request') {
                showConfirmationDialog(message);
            } else if (message.message_type === 'workflow_step_update') {
                handleStepUpdate(message);
            }
            
            showResult('ws-result', `æ”¶åˆ°æ¶ˆæ¯: ${message.message_type}`, 'success');
        }

        // æ˜¾ç¤ºç¡®è®¤å¯¹è¯æ¡†
        function showConfirmationDialog(message) {
            const { execution_id, step_id, data } = message;
            
            const confirmed = confirm(
                `ğŸ”„ å·¥ä½œæµç¡®è®¤\n\n` +
                `æ­¥éª¤: ${data.step_name}\n` +
                `${data.step_description || ''}\n\n` +
                `${data.message}\n\n` +
                `ç‚¹å‡»"ç¡®å®š"é€‰æ‹©"${data.options[0]}"ï¼Œç‚¹å‡»"å–æ¶ˆ"é€‰æ‹©"${data.options[1]}"`
            );
            
            // å‘é€ç¡®è®¤ç»“æœ
            const confirmation = {
                execution_id,
                step_id,
                confirmed,
                selected_option: confirmed ? data.options[0] : data.options[1],
                operator_notes: 'ç½‘é¡µæµ‹è¯•ç¡®è®¤'
            };
            
            // é€šè¿‡WebSocketå‘é€ç¡®è®¤
            if (websocket && websocket.readyState === WebSocket.OPEN) {
                websocket.send(JSON.stringify({
                    type: 'user_confirmation',
                    data: confirmation
                }));
            }
            
            // åŒæ—¶é€šè¿‡APIå‘é€
            apiCall(`/executions/${execution_id}/confirm`, {
                method: 'POST',
                body: JSON.stringify(confirmation),
                resultId: 'execution-result'
            });
        }

        // å¤„ç†æ­¥éª¤æ›´æ–°
        function handleStepUpdate(message) {
            const { data } = message;
            console.log(`æ­¥éª¤æ›´æ–°: ${data.step_name} - ${data.step_status}`);
            
            const statusText = `æ­¥éª¤: ${data.step_name} | çŠ¶æ€: ${data.step_status}`;
            showResult('monitoring-result', statusText, 'info');
        }

        // é€šç”¨APIè°ƒç”¨
        async function apiCall(url, options = {}) {
            try {
                if (options.resultId) {
                    showResult(options.resultId, 'æ­£åœ¨è¯·æ±‚...', 'info');
                }
                
                const response = await fetch(BASE_URL + url, {
                    headers: {
                        'Content-Type': 'application/json',
                        ...options.headers
                    },
                    ...options
                });
                
                const data = await response.json();
                
                if (data.code === 0) {
                    if (options.resultId) {
                        showResult(options.resultId, JSON.stringify(data.data, null, 2), 'success');
                    }
                    return data.data;
                } else {
                    if (options.resultId) {
                        showResult(options.resultId, `é”™è¯¯: ${data.msg}`, 'error');
                    }
                    return null;
                }
            } catch (error) {
                if (options.resultId) {
                    showResult(options.resultId, `ç½‘ç»œé”™è¯¯: ${error.message}`, 'error');
                }
                return null;
            }
        }

        // æ˜¾ç¤ºç»“æœ
        function showResult(elementId, content, type = 'info') {
            const element = document.getElementById(elementId);
            element.className = `result ${type}`;
            element.textContent = content;
        }

        // åŠ è½½å·¥ä½œæµåˆ—è¡¨
        async function loadWorkflows() {
            const workflows = await apiCall('/workflows', {
                method: 'GET',
                resultId: 'workflows-result'
            });
            
            if (workflows) {
                displayWorkflows(workflows);
            }
        }

        // æ˜¾ç¤ºå·¥ä½œæµåˆ—è¡¨
        function displayWorkflows(workflows) {
            const container = document.getElementById('workflows-container');
            container.innerHTML = '';
            
            workflows.forEach(workflow => {
                const card = document.createElement('div');
                card.className = 'workflow-card';
                card.onclick = () => showWorkflowSteps(workflow);
                
                card.innerHTML = `
                    <div class="workflow-title">${workflow.name}</div>
                    <div class="workflow-desc">${workflow.description}</div>
                    <div class="step-list">æ­¥éª¤æ•°: ${workflow.steps.length} | èµ·å§‹: ${workflow.start_step_id}</div>
                `;
                
                container.appendChild(card);
            });
        }

        // æ˜¾ç¤ºå·¥ä½œæµæ­¥éª¤
        function showWorkflowSteps(workflow) {
            let stepsText = `ğŸ“‹ å·¥ä½œæµ: ${workflow.name}\n\n`;
            stepsText += `ğŸ“„ æè¿°: ${workflow.description}\n\n`;
            stepsText += `ğŸ”¢ æ­¥éª¤åˆ—è¡¨:\n`;
            
            workflow.steps.forEach((step, index) => {
                const stepIcon = {
                    'serial_send': 'ğŸ“¡',
                    'user_confirm': 'â“',
                    'set_variable': 'ğŸ”§',
                    'delay': 'â±ï¸',
                    'log': 'ğŸ“'
                }[step.step_type] || 'ğŸ“‹';
                
                stepsText += `\n${index + 1}. ${stepIcon} ${step.name} (${step.step_type})\n`;
                if (step.description) stepsText += `   ğŸ“„ ${step.description}\n`;
                if (step.serial_command) stepsText += `   ğŸ“¡ ä¸²å£æŒ‡ä»¤: ${step.serial_command}\n`;
                if (step.expected_response) stepsText += `   ğŸ“¥ æœŸæœ›å›å¤: ${step.expected_response}\n`;
                if (step.confirm_message) stepsText += `   â“ ç¡®è®¤æ¶ˆæ¯: ${step.confirm_message}\n`;
                if (step.variable_name) stepsText += `   ğŸ”§ å˜é‡: ${step.variable_name}\n`;
            });
            
            showResult('workflows-result', stepsText, 'info');
        }

        // æ‰§è¡ŒATæµ‹è¯•å·¥ä½œæµ
        async function executeATTest() {
            const execution = await apiCall('/workflows/at_command_test/execute', {
                method: 'POST',
                body: JSON.stringify({
                    workflow_id: 'at_command_test',
                    input_variables: {},
                    operator_id: 'WEB_USER',
                    workstation_id: 'WS_TEST'
                }),
                resultId: 'execution-result'
            });
            
            if (execution) {
                currentExecutions.push(execution);
                monitorExecution(execution.execution_id);
                showResult('execution-result', 
                    `âœ… ATæµ‹è¯•å·¥ä½œæµå·²å¯åŠ¨\næ‰§è¡ŒID: ${execution.execution_id}\nçŠ¶æ€: ${execution.status}`, 
                    'success');
            }
        }

        // æ‰§è¡Œè®¾å¤‡é‡å¯å·¥ä½œæµ
        async function executeDeviceRestart() {
            const execution = await apiCall('/workflows/device_restart/execute', {
                method: 'POST',
                body: JSON.stringify({
                    workflow_id: 'device_restart',
                    input_variables: { device_id: 'ESP32_TEST' },
                    operator_id: 'WEB_USER',
                    workstation_id: 'WS_TEST'
                }),
                resultId: 'execution-result'
            });
            
            if (execution) {
                currentExecutions.push(execution);
                monitorExecution(execution.execution_id);
                showResult('execution-result', 
                    `âœ… è®¾å¤‡é‡å¯å·¥ä½œæµå·²å¯åŠ¨\næ‰§è¡ŒID: ${execution.execution_id}\nçŠ¶æ€: ${execution.status}`, 
                    'success');
            }
        }

        // ç›‘æ§æ‰§è¡ŒçŠ¶æ€
        function monitorExecution(executionId) {
            const interval = setInterval(async () => {
                const execution = await apiCall(`/executions/${executionId}`, {
                    method: 'GET'
                });
                
                if (execution) {
                    updateExecutionStatus(execution);
                    
                    if (['completed', 'failed', 'cancelled'].includes(execution.status)) {
                        clearInterval(interval);
                        
                        const statusIcon = execution.status === 'completed' ? 'âœ…' : 
                                         execution.status === 'failed' ? 'âŒ' : 'ğŸš«';
                        
                        showResult('monitoring-result', 
                            `${statusIcon} å·¥ä½œæµæ‰§è¡Œ${execution.status === 'completed' ? 'å®Œæˆ' : 'ç»“æŸ'}\n` +
                            `æ‰§è¡ŒID: ${executionId}\n` +
                            `æœ€ç»ˆçŠ¶æ€: ${execution.status}\n` +
                            `æ­¥éª¤å®Œæˆ: ${Object.keys(execution.step_results || {}).length}`,
                            execution.status === 'completed' ? 'success' : 'error');
                    }
                }
            }, 3000);
            
            // 5åˆ†é’Ÿååœæ­¢ç›‘æ§
            setTimeout(() => clearInterval(interval), 300000);
        }

        // æ›´æ–°æ‰§è¡ŒçŠ¶æ€
        function updateExecutionStatus(execution) {
            const statusText = `ğŸ“Š æ‰§è¡ŒçŠ¶æ€æ›´æ–°\n` +
                             `å·¥ä½œæµ: ${execution.workflow_name}\n` +
                             `çŠ¶æ€: ${execution.status}\n` +
                             `å½“å‰æ­¥éª¤: ${execution.current_step_id || 'æ— '}\n` +
                             `å¼€å§‹æ—¶é—´: ${execution.started_at ? new Date(execution.started_at).toLocaleString() : 'æ— '}`;
            
            showResult('monitoring-result', statusText, 'info');
        }

        // è·å–æ‰§è¡Œåˆ—è¡¨
        async function getExecutions() {
            showResult('monitoring-result', 'ğŸ“‹ å½“å‰æ‰§è¡Œå®ä¾‹:\n\n', 'info');
            
            for (const exec of currentExecutions) {
                const current = await apiCall(`/executions/${exec.execution_id}`, {
                    method: 'GET'
                });
                
                if (current) {
                    const statusIcon = current.status === 'completed' ? 'âœ…' : 
                                     current.status === 'running' ? 'âš¡' :
                                     current.status === 'paused' ? 'â¸ï¸' : 'âŒ';
                    
                    const execText = `${statusIcon} ${current.workflow_name}\n` +
                                   `   ID: ${current.execution_id}\n` +
                                   `   çŠ¶æ€: ${current.status}\n` +
                                   `   å½“å‰æ­¥éª¤: ${current.current_step_id || 'æ— '}\n\n`;
                    
                    const resultEl = document.getElementById('monitoring-result');
                    resultEl.textContent += execText;
                }
            }
        }

        // æµ‹è¯•å˜é‡è§£æ
        function testVariableResolve() {
            const input = document.getElementById('variable-test').value;
            
            // æ¨¡æ‹Ÿå˜é‡è§£æ
            const variables = {
                'device_id': 'ESP32_DEV001',
                'operator': 'å¼ å·¥ç¨‹å¸ˆ',
                'current_time': new Date().toISOString(),
                'device_info': 'ESP32_DevKit_V1',
                'test_mode': 'ç”Ÿäº§æµ‹è¯•'
            };
            
            let resolved = input;
            for (const [key, value] of Object.entries(variables)) {
                const regex = new RegExp(`\\$\\{${key}\\}`, 'g');
                resolved = resolved.replace(regex, value);
            }
            
            const resultText = `ğŸ”§ å˜é‡è§£ææµ‹è¯•\n\n` +
                             `åŸæ–‡: ${input}\n` +
                             `è§£æ: ${resolved}\n\n` +
                             `å¯ç”¨å˜é‡:\n${Object.entries(variables).map(([k,v]) => `  ${k}: ${v}`).join('\n')}`;
            
            showResult('variable-result', resultText, 'success');
        }

        // é¡µé¢åŠ è½½å®Œæˆ
        window.onload = function() {
            console.log('ğŸš€ å·¥ä½œæµç³»ç»Ÿæµ‹è¯•é¡µé¢å·²åŠ è½½');
            
            // è‡ªåŠ¨åŠ è½½å·¥ä½œæµåˆ—è¡¨
            setTimeout(() => {
                loadWorkflows();
            }, 1000);
        };
    </script>
</body>
</html>